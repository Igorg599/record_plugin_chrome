/**
 * Bundled by jsDelivr using Rollup v2.74.1 and Terser v5.15.1.
 * Original file: /npm/on-change@4.0.2/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
const e = Symbol("target"),
  t = Symbol("unsubscribe")
function s(e) {
  return (
    e instanceof Date ||
    e instanceof Set ||
    e instanceof Map ||
    e instanceof WeakSet ||
    e instanceof WeakMap ||
    ArrayBuffer.isView(e)
  )
}
var n = Array.isArray
function i(e) {
  return "symbol" == typeof e
}
const r = {
  after: (e, t) =>
    n(e) ? e.slice(t.length) : "" === t ? e : e.slice(t.length + 1),
  concat: (e, t) =>
    n(e)
      ? ((e = [...e]), t && e.push(t), e)
      : t && void 0 !== t.toString
      ? ("" !== e && (e += "."), i(t) ? e + t.toString() : e + t)
      : e,
  initial: (e) => {
    if (n(e)) return e.slice(0, -1)
    if ("" === e) return e
    const t = e.lastIndexOf(".")
    return -1 === t ? "" : e.slice(0, t)
  },
  last: (e) => {
    if (n(e)) return e[e.length - 1] || ""
    if ("" === e) return e
    const t = e.lastIndexOf(".")
    return -1 === t ? e : e.slice(t + 1)
  },
  walk: (e, t) => {
    if (n(e)) for (const s of e) t(s)
    else if ("" !== e) {
      let s = 0,
        n = e.indexOf(".")
      if (-1 === n) t(e)
      else
        for (; s < e.length; )
          -1 === n && (n = e.length),
            t(e.slice(s, n)),
            (s = n + 1),
            (n = e.indexOf(".", s))
    }
  },
  get(e, t) {
    return (
      this.walk(t, (t) => {
        e && (e = e[t])
      }),
      e
    )
  },
}
function a(e, t, s) {
  return (
    e.isUnsubscribed ||
    (t.ignoreSymbols && i(s)) ||
    (t.ignoreUnderscores && "_" === s.charAt(0)) ||
    ("ignoreKeys" in t && t.ignoreKeys.includes(s))
  )
}
class o {
  constructor(e) {
    ;(this._equals = e),
      (this._proxyCache = new WeakMap()),
      (this._pathCache = new WeakMap()),
      (this.isUnsubscribed = !1)
  }
  _getDescriptorCache() {
    return (
      void 0 === this._descriptorCache &&
        (this._descriptorCache = new WeakMap()),
      this._descriptorCache
    )
  }
  _getProperties(e) {
    const t = this._getDescriptorCache()
    let s = t.get(e)
    return void 0 === s && ((s = {}), t.set(e, s)), s
  }
  _getOwnPropertyDescriptor(e, t) {
    if (this.isUnsubscribed) return Reflect.getOwnPropertyDescriptor(e, t)
    const s = this._getProperties(e)
    let n = s[t]
    return (
      void 0 === n &&
        ((n = Reflect.getOwnPropertyDescriptor(e, t)), (s[t] = n)),
      n
    )
  }
  getProxy(e, t, s, n) {
    if (this.isUnsubscribed) return e
    const i = e[n],
      r = i || e
    this._pathCache.set(r, t)
    let a = this._proxyCache.get(r)
    return (
      void 0 === a &&
        ((a = void 0 === i ? new Proxy(e, s) : e), this._proxyCache.set(r, a)),
      a
    )
  }
  getPath(e) {
    return this.isUnsubscribed ? void 0 : this._pathCache.get(e)
  }
  isDetached(e, t) {
    return !Object.is(e, r.get(t, this.getPath(e)))
  }
  defineProperty(e, t, s) {
    return (
      !!Reflect.defineProperty(e, t, s) &&
      (this.isUnsubscribed || (this._getProperties(e)[t] = s), !0)
    )
  }
  setProperty(e, t, s, n, i) {
    if (!this._equals(i, s) || !(t in e)) {
      const i = this._getOwnPropertyDescriptor(e, t)
      return void 0 !== i && "set" in i
        ? Reflect.set(e, t, s, n)
        : Reflect.set(e, t, s)
    }
    return !0
  }
  deleteProperty(e, t, s) {
    if (Reflect.deleteProperty(e, t)) {
      if (!this.isUnsubscribed) {
        const n = this._getDescriptorCache().get(e)
        n && (delete n[t], this._pathCache.delete(s))
      }
      return !0
    }
    return !1
  }
  isSameDescriptor(e, t, s) {
    const n = this._getOwnPropertyDescriptor(t, s)
    return (
      void 0 !== e &&
      void 0 !== n &&
      Object.is(e.value, n.value) &&
      (e.writable || !1) === (n.writable || !1) &&
      (e.enumerable || !1) === (n.enumerable || !1) &&
      (e.configurable || !1) === (n.configurable || !1) &&
      e.get === n.get &&
      e.set === n.set
    )
  }
  isGetInvariant(e, t) {
    const s = this._getOwnPropertyDescriptor(e, t)
    return void 0 !== s && !0 !== s.configurable && !0 !== s.writable
  }
  unsubscribe() {
    ;(this._descriptorCache = null),
      (this._pathCache = null),
      (this._proxyCache = null),
      (this.isUnsubscribed = !0)
  }
}
function c(e) {
  return "[object Object]" === toString.call(e)
}
function h() {
  return !0
}
function l(e, t) {
  return e.length !== t.length || e.some((e, s) => t[s] !== e)
}
const u = new Set([
    "hasOwnProperty",
    "isPrototypeOf",
    "propertyIsEnumerable",
    "toLocaleString",
    "toString",
    "valueOf",
  ]),
  d = new Set(["concat", "includes", "indexOf", "join", "keys", "lastIndexOf"]),
  f = {
    push: h,
    pop: h,
    shift: h,
    unshift: h,
    copyWithin: l,
    reverse: l,
    sort: l,
    splice: l,
    flat: l,
    fill: l,
  },
  p = new Set([...u, ...d, ...Object.keys(f)])
function g(e, t) {
  if (e.size !== t.size) return !0
  for (const s of e) if (!t.has(s)) return !0
  return !1
}
const _ = ["keys", "values", "entries"],
  y = new Set(["has", "toString"]),
  w = { add: g, clear: g, delete: g, forEach: g },
  b = new Set([...y, ...Object.keys(w), ..._])
function v(e, t) {
  if (e.size !== t.size) return !0
  let s
  for (const [n, i] of e)
    if (((s = t.get(n)), s !== i || (void 0 === s && !t.has(n)))) return !0
  return !1
}
const C = new Set([...y, "get"]),
  k = { set: v, clear: v, delete: v, forEach: v },
  P = new Set([...C, ...Object.keys(k), ..._])
class S {
  constructor(e, t, s, n) {
    ;(this._path = t),
      (this._isChanged = !1),
      (this._clonedCache = new Set()),
      (this._hasOnValidate = n),
      (this._changes = n ? [] : null),
      (this.clone = void 0 === t ? e : this._shallowClone(e))
  }
  static isHandledMethod(e) {
    return u.has(e)
  }
  _shallowClone(e) {
    let t = e
    if (c(e)) t = { ...e }
    else if (n(e) || ArrayBuffer.isView(e)) t = [...e]
    else if (e instanceof Date) t = new Date(e)
    else if (e instanceof Set)
      t = new Set([...e].map((e) => this._shallowClone(e)))
    else if (e instanceof Map) {
      t = new Map()
      for (const [s, n] of e.entries()) t.set(s, this._shallowClone(n))
    }
    return this._clonedCache.add(t), t
  }
  preferredThisArg(e, t, s, i) {
    return e
      ? (n(i)
          ? (this._onIsChanged = f[t])
          : i instanceof Set
          ? (this._onIsChanged = w[t])
          : i instanceof Map && (this._onIsChanged = k[t]),
        i)
      : s
  }
  update(e, t, s) {
    const n = r.after(e, this._path)
    if ("length" !== t) {
      let e = this.clone
      r.walk(n, (t) => {
        e &&
          e[t] &&
          (this._clonedCache.has(e[t]) || (e[t] = this._shallowClone(e[t])),
          (e = e[t]))
      }),
        this._hasOnValidate &&
          this._changes.push({ path: n, property: t, previous: s }),
        e && e[t] && (e[t] = s)
    }
    this._isChanged = !0
  }
  undo(e) {
    let t
    for (let s = this._changes.length - 1; -1 !== s; s--)
      (t = this._changes[s]), (r.get(e, t.path)[t.property] = t.previous)
  }
  isChanged(e) {
    return void 0 === this._onIsChanged
      ? this._isChanged
      : this._onIsChanged(this.clone, e)
  }
}
class x extends S {
  static isHandledMethod(e) {
    return p.has(e)
  }
}
class O extends S {
  undo(e) {
    e.setTime(this.clone.getTime())
  }
  isChanged(e, t) {
    return !t(this.clone.valueOf(), e.valueOf())
  }
}
class M extends S {
  static isHandledMethod(e) {
    return b.has(e)
  }
  undo(e) {
    for (const t of this.clone) e.add(t)
    for (const t of e) this.clone.has(t) || e.delete(t)
  }
}
class m extends S {
  static isHandledMethod(e) {
    return P.has(e)
  }
  undo(e) {
    for (const [t, s] of this.clone.entries()) e.set(t, s)
    for (const t of e.keys()) this.clone.has(t) || e.delete(t)
  }
}
class D extends S {
  constructor(e, t, s, n) {
    super(void 0, t, s, n),
      (this._arg1 = s[0]),
      (this._weakValue = e.has(this._arg1))
  }
  isChanged(e) {
    return this._weakValue !== e.has(this._arg1)
  }
  undo(e) {
    this._weakValue && !e.has(this._arg1)
      ? e.add(this._arg1)
      : e.delete(this._arg1)
  }
}
class H extends S {
  constructor(e, t, s, n) {
    super(void 0, t, s, n),
      (this._weakKey = s[0]),
      (this._weakHas = e.has(this._weakKey)),
      (this._weakValue = e.get(this._weakKey))
  }
  isChanged(e) {
    return this._weakValue !== e.get(this._weakKey)
  }
  undo(e) {
    const t = e.has(this._weakKey)
    this._weakHas && !t
      ? e.set(this._weakKey, this._weakValue)
      : !this._weakHas && t
      ? e.delete(this._weakKey)
      : this._weakValue !== e.get(this._weakKey) &&
        e.set(this._weakKey, this._weakValue)
  }
}
class V {
  constructor(e) {
    ;(this._stack = []), (this._hasOnValidate = e)
  }
  static isHandledType(e) {
    return c(e) || n(e) || s(e)
  }
  static isHandledMethod(e, t) {
    return c(e)
      ? S.isHandledMethod(t)
      : n(e)
      ? x.isHandledMethod(t)
      : e instanceof Set
      ? M.isHandledMethod(t)
      : e instanceof Map
      ? m.isHandledMethod(t)
      : s(e)
  }
  get isCloning() {
    return this._stack.length > 0
  }
  start(e, t, s) {
    let i = S
    n(e)
      ? (i = x)
      : e instanceof Date
      ? (i = O)
      : e instanceof Set
      ? (i = M)
      : e instanceof Map
      ? (i = m)
      : e instanceof WeakSet
      ? (i = D)
      : e instanceof WeakMap && (i = H),
      this._stack.push(new i(e, t, s, this._hasOnValidate))
  }
  update(e, t, s) {
    this._stack[this._stack.length - 1].update(e, t, s)
  }
  preferredThisArg(e, t, s) {
    const { name: n } = e,
      i = V.isHandledMethod(s, n)
    return this._stack[this._stack.length - 1].preferredThisArg(i, n, t, s)
  }
  isChanged(e, t, s) {
    return this._stack[this._stack.length - 1].isChanged(e, t, s)
  }
  undo(e) {
    void 0 !== this._previousClone && this._previousClone.undo(e)
  }
  stop() {
    return (this._previousClone = this._stack.pop()), this._previousClone.clone
  }
}
const R = {
    equals: Object.is,
    isShallow: !1,
    pathAsArray: !1,
    ignoreSymbols: !1,
    ignoreUnderscores: !1,
    ignoreDetached: !1,
    details: !1,
  },
  A = (n, c, h = {}) => {
    h = { ...R, ...h }
    const l = Symbol("ProxyTarget"),
      { equals: u, isShallow: d, ignoreDetached: f, details: p } = h,
      g = new o(u),
      _ = "function" == typeof h.onValidate,
      y = new V(_),
      w = (e, t, s, n, i) =>
        !_ ||
        y.isCloning ||
        !0 === h.onValidate(r.concat(g.getPath(e), t), s, n, i),
      b = (e, t, s, i) => {
        a(g, h, t) || (f && g.isDetached(e, n)) || v(g.getPath(e), t, s, i)
      },
      v = (e, t, s, n, i) => {
        y.isCloning ? y.update(e, t, n) : c(r.concat(e, t), s, n, i)
      },
      C = (e) => (e && e[l]) || e,
      k = (e, t, s, i) =>
        (function (e) {
          return (
            ("object" == typeof e ? null === e : "function" != typeof e) ||
            e instanceof RegExp
          )
        })(e) ||
        "constructor" === s ||
        (d && !V.isHandledMethod(t, s)) ||
        a(g, h, s) ||
        g.isGetInvariant(t, s) ||
        (f && g.isDetached(t, n))
          ? e
          : (void 0 === i && (i = g.getPath(t)),
            g.getProxy(e, r.concat(i, s), P, l)),
      P = {
        get(n, r, a) {
          if (i(r)) {
            if (r === l || r === e) return n
            if (r === t && !g.isUnsubscribed && 0 === g.getPath(n).length)
              return g.unsubscribe(), n
          }
          const o = s(n) ? Reflect.get(n, r) : Reflect.get(n, r, a)
          return k(o, n, r)
        },
        set(e, t, s, n) {
          s = C(s)
          const i = e[l] || e,
            r = i[t]
          if (u(r, s) && t in e) return !0
          const a = w(e, t, s, r)
          return a && g.setProperty(i, t, s, n, r) ? (b(e, t, e[t], r), !0) : !a
        },
        defineProperty(e, t, s) {
          if (!g.isSameDescriptor(s, e, t)) {
            const n = e[t]
            w(e, t, s.value, n) &&
              g.defineProperty(e, t, s, n) &&
              b(e, t, s.value, n)
          }
          return !0
        },
        deleteProperty(e, t) {
          if (!Reflect.has(e, t)) return !0
          const s = Reflect.get(e, t),
            n = w(e, t, void 0, s)
          return n && g.deleteProperty(e, t, s) ? (b(e, t, void 0, s), !0) : !n
        },
        apply(t, s, i) {
          const a = s[l] || s
          if (g.isUnsubscribed) return Reflect.apply(t, a, i)
          if (
            (!1 === p || (!0 !== p && !p.includes(t.name))) &&
            V.isHandledType(a)
          ) {
            let c = r.initial(g.getPath(t))
            const h = V.isHandledMethod(a, t.name)
            y.start(a, c, i)
            let l = Reflect.apply(
              t,
              y.preferredThisArg(t, s, a),
              h ? i.map((e) => C(e)) : i
            )
            const d = y.isChanged(a, u),
              f = y.stop()
            if (
              (V.isHandledType(l) &&
                h &&
                (s instanceof Map &&
                  "get" === t.name &&
                  (c = r.concat(c, i[0])),
                (l = g.getProxy(l, c, P))),
              d)
            ) {
              const e = { name: t.name, args: i, result: l },
                s = y.isCloning ? r.initial(c) : c,
                o = y.isCloning ? r.last(c) : ""
              w(r.get(n, s), o, a, f, e) ? v(s, o, a, f, e) : y.undo(a)
            }
            return (s instanceof Map || s instanceof Set) &&
              "object" == typeof (o = l) &&
              "function" == typeof o.next
              ? (function (t, s, n, i, r) {
                  const a = t.next
                  if ("entries" === s.name)
                    t.next = function () {
                      const e = a.call(this)
                      return (
                        !1 === e.done &&
                          ((e.value[0] = r(e.value[0], s, e.value[0], i)),
                          (e.value[1] = r(e.value[1], s, e.value[0], i))),
                        e
                      )
                    }
                  else if ("values" === s.name) {
                    const o = n[e].keys()
                    t.next = function () {
                      const e = a.call(this)
                      return (
                        !1 === e.done &&
                          (e.value = r(e.value, s, o.next().value, i)),
                        e
                      )
                    }
                  } else
                    t.next = function () {
                      const e = a.call(this)
                      return (
                        !1 === e.done && (e.value = r(e.value, s, e.value, i)),
                        e
                      )
                    }
                  return t
                })(l, t, s, c, k)
              : l
          }
          var o
          return Reflect.apply(t, s, i)
        },
      },
      S = g.getProxy(n, h.pathAsArray ? [] : "", P)
    return (c = c.bind(S)), _ && (h.onValidate = h.onValidate.bind(S)), S
  }
;(A.target = (t) => (t && t[e]) || t), (A.unsubscribe = (e) => e[t] || e)
export { A as default }
//# sourceMappingURL=/sm/779363e805d043924edce0638b640d49dd07aa2fd11cba6444121cb08e5fb787.map
